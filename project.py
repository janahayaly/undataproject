# -*- coding: utf-8 -*-
"""project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11lwEWDX9UjgDrDZGGbdSyY0DbcO-YRns

Name: Jana Hayaly

Pennkey: jhayaly

Hours Worked: 9

Description: This takes in environmental and social data from the world bank and processes it in two ways. The first is it allows users to pick countries and compare them on the basis of series, over time. The second allows users to choose a country and uses prior data to make predictions for the future.
"""

#import all necessary packages

import matplotlib.pyplot as plt
import numpy as np

from sklearn.linear_model import LinearRegression
from statsmodels.tsa.ar_model import AutoReg 

import pandas as pd
import seaborn as sns
from ipywidgets import interact, fixed

class Dataframe:

  def __init__(self, filename):
    self.compas = pd.read_csv(filename)

  def get_compas(self):
    return self.compas

  def __str__(self):
    return self.compas.to_string()

def make_line_graph(country1, country2, factor, compas):

    # filter data frame to only include selected countries and factor
    country_df = compas[compas['Country Name'].isin([country1, country2]) & 
                        (compas['Series Name'] == factor)]

    # Use melt function to transform the dataframe so that year 
    # is a single column
    country_df = country_df.melt(id_vars=['Country Name'], var_name='Year', 
                                 value_name='Value')
    country_df = country_df.dropna()  # Drop any rows with NaN values

    # account for extra rows
    country_df = country_df.iloc[6:]

    # Remove the extra text from the year column
    country_df['Year'] = country_df['Year'].str.slice(0, 4)
    

    # Plot the line graph
    fig, ax = plt.subplots()
    sns.lineplot(data=country_df, x='Year', y='Value', hue='Country Name')    
    ax.set_title('{} in {} and {} over time'.format(factor, country1, country2))
    ax.set_xlabel("Year")
    ax.tick_params(axis='both', which='major', labelsize=6)
    plt.show()

def make_comp_interactions(compas):
  
    # set up user interaction for comparisons
    countries = compas['Country Name'].unique()
    series = compas['Series Name'].dropna().unique()

    interact(make_line_graph, country1=countries, country2=countries, 
             factor=series, compas=fixed(compas))

def run_comparisons():

  """
  Line Plotting Code
  """
  
   # create instances of the Dataframe class for the two datasets
  env_compas = Dataframe("environmental_worldbank_data.csv")
  soc_compas = Dataframe("social_worldbank_data.csv")

  # get the compas data for each dataset using the get_compas() method
  env_compas_data = env_compas.get_compas()
  soc_compas_data = soc_compas.get_compas()

  # run comparisons on env and soc data set
  make_comp_interactions(env_compas_data)
  make_comp_interactions(soc_compas_data)

def load_autoreg_data(country, factor, compas):
  
    country_df = compas[compas['Country Name'].isin([country]) & 
                        (compas['Series Name'] == factor)]

    # Use melt function to transform the dataframe so that year 
    # is a single column
    country_df = country_df.melt(id_vars=['Country Name'], var_name='Year', 
                                 value_name='Value')
    
    # account for extra rows
    country_df = country_df.iloc[6:]

    # replacing .. with NaN values
    country_df['Value'] = pd.to_numeric(country_df['Value'].replace('..', 
                                                                    np.nan))
    country_df = country_df.dropna()  # Drop any rows with NaN values

    return country_df

def train_and_predict(df, train_pct=0.5):
  
    train_data = df['Value'][:int(len(df) * train_pct)]
    test_data = df['Value'][int(len(df) * train_pct):]

    # Instantiate and fit the AR model with training data
    ar_model = AutoReg(train_data, lags=3).fit()

    # Make predictions for the next 25 years
    future_preds = ar_model.predict(start=len(df)-1, end=len(df)+25)

    return (test_data, future_preds)

def plot_predictions(df, country, factor):

    # get test datas and future predictions
    test_data, future_preds = train_and_predict(df)

    # Plot the line graph
    fig, ax = plt.subplots()
    ax.plot(test_data.index, test_data, label='Test Data')
    ax.plot(future_preds.index, future_preds, label='Predicted (future)')    
    ax.set_title('{} in {} predictions'.format(factor, country))
    ax.set_xlabel("Year")
    ax.tick_params(axis='both', which='major', labelsize=6)
    ax.legend()
    plt.show()

def put_autoreg_tog(country, factor, compas):

  try:
    # load in the data and account for it being empty
    df = load_autoreg_data(country, factor, compas)

    if len(df) == 0:
        print("No data available")
        return

    # train model, make predictions, plot them
    train_and_predict(df)
    plot_predictions(df, country, factor)

  # account for errors related to data availability
  except:
    print('data inconclusive')

def make_pred_interactions(compas):

    # pulling out countries and series from compas
    countries = compas['Country Name'].unique()
    series = compas['Series Name'].dropna().unique()

    # make interactions
    interact(put_autoreg_tog, country=countries,
             factor=series, compas=fixed(compas))

def run_predictions():

  # create instances of the Dataframe class for the two datasets
  env_compas = Dataframe("environmental_worldbank_data.csv")
  soc_compas = Dataframe("social_worldbank_data.csv")

  # get the compas data for each dataset using the get_compas() method
  env_compas_data = env_compas.get_compas()
  soc_compas_data = soc_compas.get_compas()

  # call interactions for environmental data
  make_pred_interactions(env_compas_data)

  # call interactions for social data
  make_pred_interactions(soc_compas_data)

if __name__ == "__main__":
  
  run_comparisons()

  run_predictions()